# Internationalization (i18n) Guide

This project uses i18next for internationalization with a standardized approach for handling translations across components.

## Structure

- `src/i18n.ts` - Main i18n configuration
- `src/i18n/locales/[language]/index.ts` - Entry point for language resources
- `src/i18n/locales/[language]/common.json` - Common strings used across the app
- `src/i18n/locales/[language]/navigation.json` - Navigation-related strings
- `src/i18n/locales/[language]/screens/` - Page-specific content

## Translation Utilities

The project uses standardized utility functions for handling translations:

1. **getTranslatableContent**: Used for content that might be a string or a React element

   - Handles missing translations with a `MissingTranslation` component
   - Example: `getTranslatableContent(hero.title, 'home.hero.title')`

2. **getStringContent**: Used for strings where we need a guaranteed string return value
   - Returns an empty string or debugging placeholder when translation is missing
   - Example: `getStringContent(buttonText, 'home.cta.buttonText') || 'Default Text'`

Both functions handle null/undefined values safely, so you should always use them to access translated content.

## Adding a New Language

1. Create a new directory in `src/i18n/locales` with the language code (e.g., `de` for German)
2. Copy the structure from an existing language folder (e.g., `en`)
3. Translate all JSON files
4. Add the language to the `languages` array in `src/context/LanguageContext.tsx`

## Creating a Page with Translations

1. Create JSON files for each supported language in their respective directories:

   - `src/i18n/locales/en/screens/new-page.json`
   - `src/i18n/locales/es/screens/new-page.json`
   - `src/i18n/locales/pt/screens/new-page.json`

2. In your page component, use the standardized approach:

```tsx
import { useLocalizedContent } from '../hooks/useLocalizedContent';
import {
  getTranslatableContent,
  getStringContent,
} from '../utils/translationUtils';

const NewPage: React.FC = () => {
  const { getContent } = useLocalizedContent('screens', 'newPage');

  // Get translations with proper typing
  const pageData = {
    title: getContent<string>('title'),
    description: getContent<string>('description'),
    buttonText: getContent<string>('buttonText'),
  };

  return (
    <div>
      <h1>{getTranslatableContent(pageData.title, 'newPage.title')}</h1>
      <p>
        {getTranslatableContent(pageData.description, 'newPage.description')}
      </p>
      <button>
        {getStringContent(pageData.buttonText, 'newPage.buttonText') ||
          'Default Button Text'}
      </button>
    </div>
  );
};
```

## Standard Pattern for React Components

For consistent translation handling, follow these steps:

1. Import the necessary hooks and utilities

   ```tsx
   import { useLocalizedContent } from '../hooks/useLocalizedContent';
   import {
     getTranslatableContent,
     getStringContent,
   } from '../utils/translationUtils';
   ```

2. Get translations using the hook

   ```tsx
   const { getContent } = useLocalizedContent('screens', 'componentNamespace');

   const translations = {
     title: getContent<string>('title'),
     description: getContent<string>('description'),
     // For nested content:
     items: getContent<Item[]>('items'),
   };
   ```

3. Use translations in your JSX with proper fallback handling

   ```tsx
   <Typography variant="h1">
     {getTranslatableContent(translations.title, 'componentNamespace.title')}
   </Typography>

   <Button>
     {getStringContent(translations.buttonText, 'componentNamespace.buttonText') || 'Default'}
   </Button>
   ```

4. Handle arrays with proper type checking
   ```tsx
   {
     Array.isArray(translations.items) ? (
       translations.items.map((item, index) => (
         <ListItem key={index}>{item.name}</ListItem>
       ))
     ) : (
       <MissingTranslation translationKey="componentNamespace.items" />
     );
   }
   ```

## Using Common Translations

For common strings (buttons, labels, etc.), use the translation namespace approach:

```tsx
// For common UI elements
const { getContent } = useLocalizedContent('common', 'buttons');
const submitButtonText = getStringContent(
  getContent<string>('submit'),
  'buttons.submit'
);
```

## Missing Translations

When a translation is missing:

1. In development mode - a visual indicator will show the missing key
2. In production - a fallback value will be used instead
3. You can provide explicit fallbacks with the OR operator:
   ```tsx
   {
     getStringContent(translations.title, 'namespace.title') || 'Default Title';
   }
   ```

## Handling Dynamic Content

For dynamic content with variables:

```tsx
// Get the translation template
const template =
  getStringContent(translations.welcomeMessage, 'welcome') ||
  'Welcome {{name}}!';

// Replace the placeholders
const finalMessage = template.replace('{{name}}', userName);
```

## Notes

- Always use `getTranslatableContent` for content that might be rendered as React elements
- Use `getStringContent` when you need guaranteed string values (button text, alt text, etc.)
- Add a fallback with `|| 'Default Text'` for critical UI elements
- Use TypeScript generics with `getContent<T>()` to ensure proper typing
